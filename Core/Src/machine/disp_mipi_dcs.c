/*
 * disp_ili9488.c
 *
 *  Created on: May 22, 2025
 *      Author: stelhs
 */
#include "disp_mipi_dcs.h"

#include <stdlib.h>
#include "stm32f407xx.h"
#include "stm32_lib/kref_alloc.h"
#include "stm32_lib/buf.h"
#include "spi_dev.h"

static bool lock = FALSE;
static struct disp *last_disp = NULL;

static void disp_destructor(void *mem)
{
    struct disp *disp = (struct disp *)mem;
    kmem_deref(&disp->spi);
}

struct disp *
disp_register(char *name, struct gpio *cs, struct gpio *dc_rs,
              SPI_HandleTypeDef *hspi,
              enum disp_orientation orient)
{
    struct disp *disp;
    disp = kzref_alloc(name, sizeof *disp, disp_destructor);

    disp->spi = spi_dev_register(name, hspi, cs);
    disp->dc_rs = dc_rs;
    disp->orient = orient;

    disp_init(disp);
    return disp;
}

static void cmd_send(struct disp *disp, u8 cmd)
{
    if (last_disp != disp)
        sleep(5);
    last_disp = disp;
    gpio_down(disp->dc_rs);
    spi_send_sync(disp->spi, &cmd, 1);
}

static void data_send(struct disp *disp, u8 *data, size_t len)
{
    if (last_disp != disp)
        sleep(5);
    last_disp = disp;
    gpio_up(disp->dc_rs);
    spi_send_sleep(disp->spi, data, len);
    gpio_down(disp->dc_rs);
}

static void data_send_sync(struct disp *disp, u8 *data, size_t len)
{
    if (last_disp != disp)
        sleep(5);
    last_disp = disp;
    gpio_up(disp->dc_rs);
    spi_send_sync(disp->spi, data, len);
    gpio_down(disp->dc_rs);
}

static void data_send_buf(struct disp *disp, struct buf *data)
{
    data_send_sync(disp, data->d, buf_len(data));
}

static void set_window(struct disp *disp, int x, int y,
                       int width, int height)
{
    u8 buf[4];
    cmd_send(disp, 0x2A); // CASET
    buf[0] = (x >> 8) & 0xFF;
    buf[1] = x & 0xFF;
    buf[2] = ((x + width - 1) >> 8) & 0xFF;
    buf[3] = (x + width - 1) & 0xFF;
    data_send_sync(disp, buf, 4);

    cmd_send(disp, 0x2B); // RASET
    buf[0] = (y >> 8) & 0xFF;
    buf[1] = y & 0xFF;
    buf[2] = ((y + height - 1) >> 8) & 0xFF;
    buf[3] = (y + height - 1) & 0xFF;
    data_send_sync(disp, buf, 4);

    cmd_send(disp, 0x2c);
}

void disp_ili9488_put_pixel(struct disp *disp,
                            int x, int y, struct color color)
{
    set_window(disp, x, y, 1, 1);
    data_send_sync(disp, (u8 *)&color, 3);
}


void disp_fill_img(struct disp *disp, int x, int y, struct img *img)
{
    thread_lock(lock);
    set_window(disp, x, y, img->width, img->height);
    data_send_buf(disp, img->buf);
    thread_unlock(lock);
}

void disp_fill(struct disp *disp,
               int x, int y,
               int width, int height,
               struct color color)
{
    int i;
    struct color *c;
    struct buf *row;

    row = buf_alloc("row", width * sizeof (struct color));
    c = (struct color *)row->d;
    for (i = 0; i < width; i++, c++)
        *c = color;
    buf_put(row, width * sizeof (struct color));

    thread_lock(lock);
    set_window(disp, x, y, width, height);
    for (i = 0; i < height; i++)
        data_send_buf(disp, row);
    //cmd_send(disp, 0x00);
    thread_unlock(lock);

    kmem_deref(&row);
}


void disp_clear(struct disp *disp)
{
    disp_fill(disp, 0, 0, disp->width, disp->height, BLACK);
}

void disp_init(struct disp *disp)
{
    // Сброс дисплея
    cmd_send(disp, 0x01); // Software Reset
    sleep(50);

    cmd_send(disp, 0x11); // SLEEP OUT
    sleep(50);

    {
        cmd_send(disp, 0x3A); // COLMOD: pixel format
        u8 data = 0x66; // 18 bit per pixel (RGB666)
        data_send(disp, &data, 1);
    }

    disp_set_orientation(disp, disp->orient);

    cmd_send(disp, 0x20);
    cmd_send(disp, 0x29); // DISPON: display enable

    disp_clear(disp);
}

void disp_set_orientation(struct disp *disp, enum disp_orientation orient)
{
    u8 data;
    thread_lock(lock);
    cmd_send(disp, 0x36); // MADCTL: setup orientation
    switch(orient) {
    case DISP_ORIENT_PORTRAIT:
        data = 0x40;
        disp->width = 320;
        disp->height = 480;
        break;
    case DISP_ORIENT_PORTRAIT_MIRROR:
        data = 0x80;
        disp->width = 320;
        disp->height = 480;
        break;
    case DISP_ORIENT_LANDSCAPE:
        data = 0xE0;
        disp->width = 480;
        disp->height = 320;
        break;
    case DISP_ORIENT_LANDSCAPE_MIRROR:
        data = 0x20;
        disp->width = 480;
        disp->height = 320;
        break;
    }
    data |= (1 << 3);
    data_send(disp, &data, 1);
    thread_unlock(lock);
}


void disp_line(struct disp *disp,
               int x0, int y0, int x1, int y1,
               int thickness, struct color color) {
    thread_lock(lock);
    // Разница по координатам
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);

    // Определяем направление движения
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;

    // Начальное значение ошибки
    int err = dx - dy;

    // Половина толщины для симметричного рисования
    int half_thickness = thickness / 2;

    while (1) {
        // Рисуем текущий пиксель с учетом толщины
        for (int tx = -half_thickness; tx <= half_thickness; tx++) {
            for (int ty = -half_thickness; ty <= half_thickness; ty++) {
                // Проверяем границы экрана перед рисованием
                int px = x0 + tx;
                int py = y0 + ty;
                if (px >= 0 && px < 480 && py >= 0 && py < 320) {
                    disp_ili9488_put_pixel(disp, px, py, color);
                }
            }
        }

        // Если достигли конечной точки, выходим из цикла
        if (x0 == x1 && y0 == y1) {
            break;
        }

        // Вычисляем ошибку и корректируем координаты
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
    thread_unlock(lock);
}


void disp_rect(struct disp *disp,
                       int x, int y,
                       int width, int height,
                       int thickness,
                       struct color color)
{
    disp_fill(disp, x, y, width, thickness, color);
    disp_fill(disp, x, y + height, width, thickness, color);
    disp_fill(disp, x, y, thickness, height, color);
    disp_fill(disp, x + width - thickness, y,
                      thickness, height, color);
}

void disp_text(struct disp *disp, char *text,
                           int x, int y,
                           struct text_style *style)
{
    struct img *img;
    int i;
    int len = strlen(text);

    for (i = 0; i < len; i++) {
        img = font_symbol_img(text[i], style->font, style->fontsize,
                              style->color, style->bg_color);
        disp_fill_img(disp, x + i * 6 * style->fontsize, y, img);
        kmem_deref(&img);
    }
}

static void img_destructor(void *mem)
{
    struct img *img = (struct img *)mem;
    kmem_deref(&img->buf);
}

struct img *img_alloc(char *name, int width, int height)
{
    struct img *img;
    int buf_len = width * height * 3;
    img = kref_alloc(name, sizeof *img, img_destructor);
    img->buf = buf_alloc("img_buf", buf_len);
    buf_memset(img->buf, 0);
    img->width = width;
    img->height = height;
    buf_put(img->buf, buf_len);
    return img;
}

struct img *font_symbol_img(char ch, u8 *font, int fontsize,
                            struct color color, struct color bg_color) {
    int sym_width = 5;
    int sym_height = 8;
    struct img *img = img_alloc("font_sym",
                                (sym_width + 1) * fontsize,
                                sym_height * fontsize);

    u8 *sym_bitmap = font + ch * sym_width;



    int buf_index = 0;

    for (int y = 0; y < sym_height; y++) {
        struct color *pixel;
        for (int x = 0; x < sym_width; x++) {
            u8 column = sym_bitmap[x];
            for (int fx = 0; fx < fontsize; fx++) {
                for (int fy = 0; fy < fontsize; fy++) {
                    int pixel_x = x * fontsize + fx;
                    int pixel_y = y * fontsize + fy;
                    int pixel_index = (pixel_y * (sym_width + 1) *
                                       fontsize + pixel_x) * 3;
                    pixel = (struct color *)(img->buf->d + pixel_index);

                    if (column & (1 << y))
                        *pixel = color;
                    else
                        *pixel = bg_color;
                    buf_index += 3;
                }
            }
        }
        // Draw space delimeter
        for (int fx = 0; fx < fontsize; fx++) {
            for (int fy = 0; fy < fontsize; fy++) {
                int pixel_x = 5 * fontsize + fx;
                int pixel_y = y * fontsize + fy;
                int pixel_index = (pixel_y * (sym_width + 1) *
                                   fontsize + pixel_x) * 3;
                pixel = (struct color *)(img->buf->d + pixel_index);
                *pixel = bg_color;
                buf_index += 3;
            }
        }
    }

    return img;
}

int disp_text_width(struct text_style *ts, int text_len)
{
    return 6 * ts->fontsize * text_len;
}

int disp_text_height(struct text_style *ts, int text_len)
{
    return 8 * ts->fontsize;
}


u8 font_rus[] = {
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x3E, 0x5B, 0x4F, 0x5B, 0x3E,
    0x3E, 0x6B, 0x4F, 0x6B, 0x3E,
    0x1C, 0x3E, 0x7C, 0x3E, 0x1C,
    0x18, 0x3C, 0x7E, 0x3C, 0x18,
    0x1C, 0x57, 0x7D, 0x57, 0x1C,
    0x1C, 0x5E, 0x7F, 0x5E, 0x1C,
    0x00, 0x18, 0x3C, 0x18, 0x00,
    0xFF, 0xE7, 0xC3, 0xE7, 0xFF,
    0x00, 0x18, 0x24, 0x18, 0x00,
    0xFF, 0xE7, 0xDB, 0xE7, 0xFF,
    0x30, 0x48, 0x3A, 0x06, 0x0E,
    0x26, 0x29, 0x79, 0x29, 0x26,
    0x40, 0x7F, 0x05, 0x05, 0x07,
    0x40, 0x7F, 0x05, 0x25, 0x3F,
    0x5A, 0x3C, 0xE7, 0x3C, 0x5A,
    0x7F, 0x3E, 0x1C, 0x1C, 0x08,
    0x08, 0x1C, 0x1C, 0x3E, 0x7F,
    0x14, 0x22, 0x7F, 0x22, 0x14,
    0x5F, 0x5F, 0x00, 0x5F, 0x5F,
    0x06, 0x09, 0x7F, 0x01, 0x7F,
    0x00, 0x66, 0x89, 0x95, 0x6A,
    0x60, 0x60, 0x60, 0x60, 0x60,
    0x94, 0xA2, 0xFF, 0xA2, 0x94,
    0x08, 0x04, 0x7E, 0x04, 0x08,
    0x10, 0x20, 0x7E, 0x20, 0x10,
    0x08, 0x08, 0x2A, 0x1C, 0x08,
    0x08, 0x1C, 0x2A, 0x08, 0x08,
    0x1E, 0x10, 0x10, 0x10, 0x10,
    0x0C, 0x1E, 0x0C, 0x1E, 0x0C,
    0x30, 0x38, 0x3E, 0x38, 0x30,
    0x06, 0x0E, 0x3E, 0x0E, 0x06,
    0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x5F, 0x00, 0x00,
    0x00, 0x07, 0x00, 0x07, 0x00,
    0x14, 0x7F, 0x14, 0x7F, 0x14,
    0x24, 0x2A, 0x7F, 0x2A, 0x12,
    0x23, 0x13, 0x08, 0x64, 0x62,
    0x36, 0x49, 0x56, 0x20, 0x50,
    0x00, 0x08, 0x07, 0x03, 0x00,
    0x00, 0x1C, 0x22, 0x41, 0x00,
    0x00, 0x41, 0x22, 0x1C, 0x00,
    0x2A, 0x1C, 0x7F, 0x1C, 0x2A,
    0x08, 0x08, 0x3E, 0x08, 0x08,
    0x00, 0x80, 0x70, 0x30, 0x00,
    0x08, 0x08, 0x08, 0x08, 0x08,
    0x00, 0x00, 0x60, 0x60, 0x00,
    0x20, 0x10, 0x08, 0x04, 0x02,
    0x3E, 0x51, 0x49, 0x45, 0x3E,
    0x00, 0x42, 0x7F, 0x40, 0x00,
    0x72, 0x49, 0x49, 0x49, 0x46,
    0x21, 0x41, 0x49, 0x4D, 0x33,
    0x18, 0x14, 0x12, 0x7F, 0x10,
    0x27, 0x45, 0x45, 0x45, 0x39,
    0x3C, 0x4A, 0x49, 0x49, 0x31,
    0x41, 0x21, 0x11, 0x09, 0x07,
    0x36, 0x49, 0x49, 0x49, 0x36,
    0x46, 0x49, 0x49, 0x29, 0x1E,
    0x00, 0x00, 0x24, 0x00, 0x00,
    0x00, 0x40, 0x34, 0x00, 0x00,
    0x00, 0x08, 0x14, 0x22, 0x41,
    0x14, 0x14, 0x14, 0x14, 0x14,
    0x00, 0x41, 0x22, 0x14, 0x08,
    0x02, 0x01, 0x59, 0x09, 0x06,
    0x3E, 0x41, 0x5D, 0x59, 0x4E,
    0x7C, 0x12, 0x11, 0x12, 0x7C,
    0x7F, 0x49, 0x49, 0x49, 0x36,
    0x3E, 0x41, 0x41, 0x41, 0x22,
    0x7F, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x49, 0x49, 0x49, 0x41,
    0x7F, 0x09, 0x09, 0x09, 0x01,
    0x3E, 0x41, 0x41, 0x51, 0x73,
    0x7F, 0x08, 0x08, 0x08, 0x7F,
    0x00, 0x41, 0x7F, 0x41, 0x00,
    0x20, 0x40, 0x41, 0x3F, 0x01,
    0x7F, 0x08, 0x14, 0x22, 0x41,
    0x7F, 0x40, 0x40, 0x40, 0x40,
    0x7F, 0x02, 0x1C, 0x02, 0x7F,
    0x7F, 0x04, 0x08, 0x10, 0x7F,
    0x3E, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x09, 0x09, 0x09, 0x06,
    0x3E, 0x41, 0x51, 0x21, 0x5E,
    0x7F, 0x09, 0x19, 0x29, 0x46,
    0x26, 0x49, 0x49, 0x49, 0x32,
    0x03, 0x01, 0x7F, 0x01, 0x03,
    0x3F, 0x40, 0x40, 0x40, 0x3F,
    0x1F, 0x20, 0x40, 0x20, 0x1F,
    0x3F, 0x40, 0x38, 0x40, 0x3F,
    0x63, 0x14, 0x08, 0x14, 0x63,
    0x03, 0x04, 0x78, 0x04, 0x03,
    0x61, 0x59, 0x49, 0x4D, 0x43,
    0x00, 0x7F, 0x41, 0x41, 0x41,
    0x02, 0x04, 0x08, 0x10, 0x20,
    0x00, 0x41, 0x41, 0x41, 0x7F,
    0x04, 0x02, 0x01, 0x02, 0x04,
    0x40, 0x40, 0x40, 0x40, 0x40,
    0x00, 0x03, 0x07, 0x08, 0x00,
    0x20, 0x54, 0x54, 0x78, 0x40,
    0x7F, 0x28, 0x44, 0x44, 0x38,
    0x38, 0x44, 0x44, 0x44, 0x28,
    0x38, 0x44, 0x44, 0x28, 0x7F,
    0x38, 0x54, 0x54, 0x54, 0x18,
    0x00, 0x08, 0x7E, 0x09, 0x02,
    0x18, 0xA4, 0xA4, 0x9C, 0x78,
    0x7F, 0x08, 0x04, 0x04, 0x78,
    0x00, 0x44, 0x7D, 0x40, 0x00,
    0x20, 0x40, 0x40, 0x3D, 0x00,
    0x7F, 0x10, 0x28, 0x44, 0x00,
    0x00, 0x41, 0x7F, 0x40, 0x00,
    0x7C, 0x04, 0x78, 0x04, 0x78,
    0x7C, 0x08, 0x04, 0x04, 0x78,
    0x38, 0x44, 0x44, 0x44, 0x38,
    0xFC, 0x18, 0x24, 0x24, 0x18,
    0x18, 0x24, 0x24, 0x18, 0xFC,
    0x7C, 0x08, 0x04, 0x04, 0x08,
    0x48, 0x54, 0x54, 0x54, 0x24,
    0x04, 0x04, 0x3F, 0x44, 0x24,
    0x3C, 0x40, 0x40, 0x20, 0x7C,
    0x1C, 0x20, 0x40, 0x20, 0x1C,
    0x3C, 0x40, 0x30, 0x40, 0x3C,
    0x44, 0x28, 0x10, 0x28, 0x44,
    0x4C, 0x90, 0x90, 0x90, 0x7C,
    0x44, 0x64, 0x54, 0x4C, 0x44,
    0x00, 0x08, 0x36, 0x41, 0x00,
    0x00, 0x00, 0x77, 0x00, 0x00,
    0x00, 0x41, 0x36, 0x08, 0x00,
    0x02, 0x01, 0x02, 0x04, 0x02,
    0x3C, 0x26, 0x23, 0x26, 0x3C,
    0x1E, 0xA1, 0xA1, 0x61, 0x12,
    0x3A, 0x40, 0x40, 0x20, 0x7A,
    0x38, 0x54, 0x54, 0x55, 0x59,
    0x21, 0x55, 0x55, 0x79, 0x41,
    0x22, 0x54, 0x54, 0x78, 0x42,
    0x21, 0x55, 0x54, 0x78, 0x40,
    0x20, 0x54, 0x55, 0x79, 0x40,
    0x0C, 0x1E, 0x52, 0x72, 0x12,
    0x39, 0x55, 0x55, 0x55, 0x59,
    0x39, 0x54, 0x54, 0x54, 0x59,
    0x39, 0x55, 0x54, 0x54, 0x58,
    0x00, 0x00, 0x45, 0x7C, 0x41,
    0x00, 0x02, 0x45, 0x7D, 0x42,
    0x00, 0x01, 0x45, 0x7C, 0x40,
    0x7D, 0x12, 0x11, 0x12, 0x7D,
    0xF0, 0x28, 0x25, 0x28, 0xF0,
    0x7C, 0x54, 0x55, 0x45, 0x00,
    0x20, 0x54, 0x54, 0x7C, 0x54,
    0x7C, 0x0A, 0x09, 0x7F, 0x49,
    0x32, 0x49, 0x49, 0x49, 0x32,
    0x3A, 0x44, 0x44, 0x44, 0x3A,
    0x32, 0x4A, 0x48, 0x48, 0x30,
    0x3A, 0x41, 0x41, 0x21, 0x7A,
    0x3A, 0x42, 0x40, 0x20, 0x78,
    0x00, 0x9D, 0xA0, 0xA0, 0x7D,
    0x3D, 0x42, 0x42, 0x42, 0x3D,
    0x3D, 0x40, 0x40, 0x40, 0x3D,
    0x3C, 0x24, 0xFF, 0x24, 0x24,
    0x48, 0x7E, 0x49, 0x43, 0x66,
    0x2B, 0x2F, 0xFC, 0x2F, 0x2B,
    0xFF, 0x09, 0x29, 0xF6, 0x20,
    0xC0, 0x88, 0x7E, 0x09, 0x03,
    0x20, 0x54, 0x54, 0x79, 0x41,
    0x00, 0x00, 0x44, 0x7D, 0x41,
    0x30, 0x48, 0x48, 0x4A, 0x32,
    0x38, 0x40, 0x40, 0x22, 0x7A,
    0x00, 0x7A, 0x0A, 0x0A, 0x72,
    0x7D, 0x0D, 0x19, 0x31, 0x7D,
    0x26, 0x29, 0x29, 0x2F, 0x28,
    0x26, 0x29, 0x29, 0x29, 0x26,
    0x30, 0x48, 0x4D, 0x40, 0x20,
    0x38, 0x08, 0x08, 0x08, 0x08,
    0x08, 0x08, 0x08, 0x08, 0x38,
    0x2F, 0x10, 0xC8, 0xAC, 0xBA,
    0x2F, 0x10, 0x28, 0x34, 0xFA,
    0x00, 0x00, 0x7B, 0x00, 0x00,
    0x08, 0x14, 0x2A, 0x14, 0x22,
    0x22, 0x14, 0x2A, 0x14, 0x08,
    0x55, 0x00, 0x55, 0x00, 0x55,
    0xAA, 0x55, 0xAA, 0x55, 0xAA,
    0xFF, 0x55, 0xFF, 0x55, 0xFF,
    0x00, 0x00, 0x00, 0xFF, 0x00,
    0x10, 0x10, 0x10, 0xFF, 0x00,
    0x14, 0x14, 0x14, 0xFF, 0x00,
    0x10, 0x10, 0xFF, 0x00, 0xFF,
    0x10, 0x10, 0xF0, 0x10, 0xF0,
    0x38, 0x55, 0x54, 0x55, 0x18,
    0x14, 0x14, 0xF7, 0x00, 0xFF,
    0x00, 0x00, 0xFF, 0x00, 0xFF,
    0x14, 0x14, 0xF4, 0x04, 0xFC,
    0x14, 0x14, 0x17, 0x10, 0x1F,
    0x10, 0x10, 0x1F, 0x10, 0x1F,
    0x14, 0x14, 0x14, 0x1F, 0x00,
    0x14, 0x14, 0x14, 0x1F, 0x00,
    0x7C, 0x12, 0x11, 0x12, 0x7C,
    0x7F, 0x49, 0x49, 0x49, 0x30,
    0x7F, 0x49, 0x49, 0x49, 0x36,
    0x7F, 0x01, 0x01, 0x01, 0x01,
    0x60, 0x3F, 0x21, 0x3F, 0x60,
    0x7F, 0x49, 0x49, 0x49, 0x41,
    0x63, 0x14, 0x7F, 0x14, 0x63,
    0x22, 0x41, 0x49, 0x49, 0x36,
    0x7F, 0x10, 0x08, 0x04, 0x7F,
    0x7F, 0x10, 0x09, 0x04, 0x7F,
    0x7F, 0x08, 0x14, 0x22, 0x41,
    0x40, 0x3F, 0x01, 0x01, 0x7F,
    0x7F, 0x02, 0x1C, 0x02, 0x7F,
    0x7F, 0x08, 0x08, 0x08, 0x7F,
    0x3E, 0x41, 0x41, 0x41, 0x3E,
    0x7F, 0x01, 0x01, 0x01, 0x7F,
    0x7F, 0x09, 0x09, 0x09, 0x06,
    0x3E, 0x41, 0x41, 0x41, 0x22,
    0x03, 0x01, 0x7F, 0x01, 0x03,
    0x47, 0x48, 0x28, 0x10, 0x0F,
    0x1C, 0x22, 0x7F, 0x22, 0x1C,
    0x63, 0x14, 0x08, 0x14, 0x63,
    0x3F, 0x20, 0x20, 0x3F, 0x60,
    0x07, 0x08, 0x08, 0x08, 0x7F,
    0x7F, 0x40, 0x7C, 0x40, 0x7F,
    0x3F, 0x20, 0x3C, 0x20, 0x7F,
    0x01, 0x3F, 0x48, 0x48, 0x30,
    0x7F, 0x48, 0x30, 0x00, 0x7F,
    0x7F, 0x48, 0x48, 0x48, 0x30,
    0x22, 0x41, 0x49, 0x49, 0x3E,
    0x7F, 0x08, 0x3E, 0x41, 0x3E,
    0x46, 0x29, 0x19, 0x09, 0x7F,
    0x20, 0x54, 0x54, 0x78, 0x40,
    0x3E, 0x49, 0x45, 0x45, 0x38,
    0x38, 0x54, 0x54, 0x54, 0x28,
    0x7C, 0x04, 0x04, 0x04, 0x00,
    0x60, 0x38, 0x24, 0x38, 0x60,
    0x38, 0x54, 0x54, 0x54, 0x18,
    0x6C, 0x10, 0x7C, 0x10, 0x6C,
    0x28, 0x44, 0x54, 0x54, 0x28,
    0x7C, 0x20, 0x10, 0x08, 0x7C,
    0x7C, 0x20, 0x12, 0x08, 0x7C,
    0x7C, 0x10, 0x28, 0x44, 0x00,
    0x40, 0x38, 0x04, 0x04, 0x7C,
    0x7C, 0x08, 0x10, 0x08, 0x7C,
    0x7C, 0x10, 0x10, 0x7C, 0x00,
    0x38, 0x44, 0x44, 0x44, 0x38,
    0x7C, 0x04, 0x04, 0x04, 0x7C,
    0xFC, 0x18, 0x24, 0x24, 0x18,
    0x38, 0x44, 0x44, 0x44, 0x28,
    0x04, 0x04, 0x7C, 0x04, 0x04,
    0x4C, 0x90, 0x90, 0x90, 0x7C,
    0x10, 0x28, 0x7C, 0x28, 0x10,
    0x44, 0x28, 0x10, 0x28, 0x44,
    0x3C, 0x20, 0x20, 0x3C, 0x60,
    0x0C, 0x10, 0x10, 0x10, 0x7C,
    0x7C, 0x40, 0x70, 0x40, 0x7C,
    0x7C, 0x40, 0x70, 0x40, 0xBC,
    0x04, 0x7C, 0x50, 0x70, 0x00,
    0x7C, 0x50, 0x20, 0x00, 0x7C,
    0x7C, 0x50, 0x50, 0x20, 0x00,
    0x28, 0x44, 0x54, 0x54, 0x38,
    0x7C, 0x10, 0x38, 0x44, 0x38,
    0x48, 0x34, 0x14, 0x7C, 0x00,
};




